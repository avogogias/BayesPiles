<!DOCTYPE html>
<html
>
<head>
<link rel="stylesheet" type="text/css" href="bayespiles-styles.css">
</head>
<title>BayesPiles</title>
<body>
    <div id="mainMenu">
        <div id="sessions">
				<div id="bpc"> 
<!--		
			<button type="button" onclick="saveSession()">Save Session</button> 
            <button type="button" onclick="exportSession()">Export Session</button> 
            <button type="button" onclick="undo()" hidden>Undo</button>       
            <button type="button" onclick="redo()" hidden>Redo</button>		
            Animate:  <input id="animateCheckBox"type="checkbox" checked/>	
			Zoom:  <input id="cellSizeBox" type="range" name="cellSizeBox" min="1" max="20" onchange="updateCellSize()" value="4"/> 
TV Commented-->
            <!-- <br/> -->
            <!-- <label>Session Name: </label><input type="text" id="sessionName" size="80"> -->
        <!-- </div> -->
        <!-- <br/> -->
        <!-- <div id="pileMenu"> -->
		<label class="sliderLabel">Sorted by:</label>            
          <input type = "radio"
                 name = "sortBy"
				 onchange = "sortNetworks(this);"
                 id = "sort_run_id"
                 value = "run" /> 
                 <!-- TVchecked = "checked" /> -->
          <label for = "sort_run_id" class="sliderLabel">run ID</label>
          <input type = "radio"
                 name = "sortBy"
				 onchange = "sortNetworks(this);"				 
                 id = "sort_desc"
                 value = "descending" />
          <label for = "sort_desc" class="sliderLabel">score</label>		  
          <input type = "radio"
                 name = "sortBy"
				 onchange = "sortNetworks(this);"				 
                 id = "sort_iteration"
                 value = "ascending" />
          <label for = "sort_iteration" class="sliderLabel">iteration</label>
        <label class="sliderLabel">Node Order:</label> 
            <select id="allNodeOrder" onchange="allNodeOrderChanged()">
                <option class="sliderLabel">Data: As indicated in data</option>
                <option class="sliderLabel">Global: Same for all matrices </option>
                <option class="sliderLabel" hidden>Individual: Optimized for each pile</option>
            </select>
        <label class="sliderLabel">Cover Matrix:</label>     
            <select id="allCover" onchange="allCoverChanged()">
                <option class="sliderLabel">Summary</option>
                <option hidden>Bar Charts</option>
                <option hidden>Trend</option>
                <option hidden>Variability</option>
                <option class="sliderLabel" hidden>Sequential Difference</option>
                <option class="sliderLabel">Direct Difference (to hovered matrix)</option>
            </select>		
<!-- TV        </div> -->
		<!-- TV 
		<div>
			<button class="descend">sort descending</button>
			<button class="byDataSet">sort by data set</button>
		</div>
		-->
		
		<!-- TV
		<label class="sliderLabel">Sorted by:</label> 
            <select id="allSort" onchange="sortNets();">
                <option class="sliderLabel">run ID</option>
                <option class="sliderLabel">score</option>
                <option class="sliderLabel">iteration</option>
            </select>
		-->
			<text class="sliderLabel">Zoom:</text> <input id="cellSizeBox" type="range" name="cellSizeBox" min="1" max="20" onchange="updateCellSize();updateZoomPercentage(this.value);" value="6"/><input type="text" style="width: 30px; class="sliderLabel" id="zoomPerc" value="" readonly>
		  <label for = "gr_id" class="sliderLabel">Grid:</label>
		  <input type="checkbox" id="gr_id" name="grid_checkbox" onchange="redrawPiles(piles);"/>
          
        

				  
			<!-- TV <form id="filterNodesForm"> -->
				<text class="sliderLabel">Filter nodes:<text> <input type="checkbox" id="cbox4" name="node_filter_checkbox" onchange="updateControls(this);redrawPiles(piles);"/><input id="connectivityThresSlider" type="range" name="connectivityThres" min="0" max="100" onchange="redrawPiles(piles);updateConnectivity(this.value);" value="0" disabled="true"/><input type="text" style="width: 30px;" class="sliderLabel" id="textCon" value="" readonly>
			<!-- TV </form> -->		
			<!-- TV<form id="filterEdgesForm">-->
				<text class="sliderLabel">Filter edges:<text> <input type="checkbox" id="cbox" name="edge_filter_checkbox" onchange="updateControls(this);redrawPiles(piles);"/><input id="percentageThresSlider" type="range" name="percentageThres" min="0" max="100" onchange="redrawPiles(piles);updatePercentage(this.value);" value="0" disabled="true"/><input type="text" style="width: 30px;" class="sliderLabel" id="textPerc" value="" readonly>
			<!-- TV</form>			-->	

          <label class="sliderLabel">Mode:</label>            
          <input hidden type = "radio"
                 name = "modeOf"
				 onchange = "redrawPiles(piles);timeline.updateLayout(0,false);allCoverChanged();"
                 id = "top-down_id"
                 value = "top-down"
                 checked = "checked" />
          <label hidden for = "top-down_id" class="sliderLabel">Top-Down</label>
          <input hidden type = "radio"
                 name = "modeOf"
				 onchange = "redrawPiles(piles);timeline.updateLayout(0,false);allCoverChanged();"				 
                 id = "dim_id"
                 value = "ascending" />
          <label hidden for = "dim_id" class="sliderLabel">Diamond</label>
          <input hidden type = "radio"
                 name = "modeOf"
				 onchange = "redrawPiles(piles);timeline.updateLayout(0,false);allCoverChanged();"				 
                 id = "sk_id"
                 value = "descending" />
          <label hidden for = "sk_id" class="sliderLabel">Skeleton</label>	
		  <!-- ML related modes	-->
          <input hidden type = "radio"
                 name = "modeOf"
				 onchange = "redrawPiles(piles);timeline.updateLayout(0,false);allCoverChanged();"
                 id = "order_id"
                 value = "order"
                 checked = "checked" />		  
		  <label hidden for = "order_id" class="sliderLabel">Order</label> <!-- ML related	-->		
          <input hidden type = "radio"
                 name = "modeOf"
				 onchange = "redrawPiles(piles);timeline.updateLayout(0,false);allCoverChanged();"
                 id = "orderCol_id"
                 value = "order"
                 checked = "checked" />		  
		  <label hidden for = "orderCol_id" class="sliderLabel">Order+Colour</label> <!-- ML related	-->			  
          <input hidden type = "radio"
                 name = "modeOf"
				 onchange = "redrawPiles(piles);timeline.updateLayout(0,false);allCoverChanged();"				 
                 id = "orien_id"
                 value = "descending" />
          <label hidden for = "orien_id" class="sliderLabel">Orientation</label>	
          <input type = "radio"
                 name = "modeOf"
				 onchange = "redrawPiles(piles);timeline.updateLayout(0,false);allCoverChanged();"				 
                 id = "orien2_id"
                 value = "descending" 
				 checked = "checked" />
          <label for = "orien2_id" class="sliderLabel">Orientation</label>		  
          <input type = "radio"
                 name = "modeOf"
				 onchange = "redrawPiles(piles);timeline.updateLayout(0,false);allCoverChanged();"				 
                 id = "orienCol_id"
                 value = "descending" />
          <label for = "orienCol_id" class="sliderLabel">Orientation+Colour</label>				  

<input type="textarea" rows="1" id="filteredNodesList" placeholder="filtered nodes appear here." value="" readonly>
			
			
			
<!--TV		
			<table class="fixed">
			<col width="10%" />
			<col width="3%" />
			<col width="23%" />
			<col width="6%" />

			<tr>
				<td><text class="sliderLabel">Zoom:</text></td><td> </td><td> <input id="cellSizeBox" type="range" name="cellSizeBox" min="1" max="20" onchange="updateCellSize()" value="6"/></td><td></td><td></td>
			</tr>
			<tr>
				<form id="filterEdgesForm">
				<td><text class="sliderLabel">Filter edges:<text></td><td> <input type="checkbox" id="cbox" name="edge_filter_checkbox" onchange="updateControls(this);redrawPiles(piles);"/></td><td><input id="percentageThresSlider" type="range" name="percentageThres" min="0" max="100" onchange="redrawPiles(piles);updatePercentage(this.value);" value="0" disabled="true"/></td><td style="width: 100%;"><input type="text" class="sliderLabel" id="textPerc" value="" readonly></td><td></td>
				</form>
			</tr>
			<tr>
				<form id="filterNodesForm">
				<td><text class="sliderLabel">Filter nodes:<text></td><td> <input type="checkbox" id="cbox4" name="node_filter_checkbox" onchange="updateControls(this);redrawPiles(piles);"/></td><td><input id="connectivityThresSlider" type="range" name="connectivityThres" min="0" max="100" onchange="redrawPiles(piles);updateConnectivity(this.value);" value="0" disabled="true"/></td><td><input type="text" id="textCon" value="" readonly></td><td><input type="textarea" rows="1" id="filteredNodesList" placeholder="filtered nodes appear here." value="" readonly></td>
				</form>
			</tr>
-->

			
	<!--TV	
			<tr>
				<form id="showAAH">
				<td><text class="sliderLabel">Diamond mode:<text></td><td> <input type="checkbox" id="cbox2" name="direction_checkbox" onchange="updateControls(this);redrawPiles(piles);"/></td><td></td></td><td></td>
				</form>
			</tr>
			<tr>
				<form id="skelMode">
				<td><text class="sliderLabel">Skeleton mode:<text></td><td> <input type="checkbox" id="cbox3" name="skeleton_checkbox" onchange="updateControls(this);redrawPiles(piles);timeline.updateLayout(0,false);"/></td><td></td></td><td></td>
				</form>
			</tr>
	-->	
<!--TV			</table>	-->
		</div>		
<!--TV		<div>
          <label class="sliderLabel">Mode:</label>            
          <input type = "radio"
                 name = "modeOf"
				 onchange = "redrawPiles(piles);timeline.updateLayout(0,false);allCoverChanged();"
                 id = "top-down_id"
                 value = "top-down"
                 checked = "checked" />
          <label for = "top-down_id" class="sliderLabel">Top-Down</label>
          <input type = "radio"
                 name = "modeOf"
				 onchange = "redrawPiles(piles);timeline.updateLayout(0,false);allCoverChanged();"				 
                 id = "dim_id"
                 value = "ascending" />
          <label for = "dim_id" class="sliderLabel">Diamond</label>
          <input type = "radio"
                 name = "modeOf"
				 onchange = "redrawPiles(piles);timeline.updateLayout(0,false);allCoverChanged();"				 
                 id = "sk_id"
                 value = "descending" />
          <label for = "sk_id" class="sliderLabel">Skeleton</label>
        </div> 		
-->		
        <div id="chartTimeline" style="margin-top:10px"></div>
        <div id="pilesPlot" height="1000"></div>
<!--TV    </div>  -->

        <script src="lib/d3.min.js"></script>
        <script src="lib/jquery.js"></script>
        <script src="lib/colors.js"></script>
        <script src="lib/science.js"></script>
        <script src="lib/reorder.js"></script>
        <script src="lib/jstorage.js"></script>
        <script src="lib/three.min.js"></script>
        <script src="lib/glUtilsML.js"></script>
        <script src="lib/OrbitControls.js"></script>
        
        <script src="classes/pileML.js"></script>
        <script src="classes/matrixML.js"></script>
        <script src="classes/timelineML.js"></script>
        <script src="classes/slider.js"></script>
        <script src="classes/PileTools.js"></script>
        <script src="classes/sessions.js"></script>
        <script src="classes/pileutilsML.js"></script>
        <script src="classes/animations.js"></script>
        
        <script src="fonts/gentilis_bold.typeface.js"></script>
        <script src="fonts/gentilis_regular.typeface.js"></script>
        <script src="fonts/optimer_bold.typeface.js"></script>
        <script src="fonts/optimer_regular.typeface.js"></script>
        <script src="fonts/helvetiker_bold.typeface.js"></script>
        <script src="fonts/helvetiker_regular.typeface.js"></script>
        <script src="fonts/droid/droid_sans_regular.typeface.js"></script>
        <script src="fonts/droid/droid_sans_bold.typeface.js"></script>
        <script src="fonts/droid/droid_serif_regular.typeface.js"></script>
        <script src="fonts/droid/droid_serif_bold.typeface.js"></script>

<!-- TV        <script src="http://www.macwright.org/simple-statistics/simple_statistics.js"></script> 	-->

        <script type="x-shader/x-vertex" id="vertexshader">
           attribute vec3 customColor;
           varying vec3 vColor;
           void main() {
              vColor = customColor;
              gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
           }
        </script>
        <script type="x-shader/x-fragment" id="fragmentshader">
           varying vec3 vColor;
           void main() {
             gl_FragColor = vec4( vColor, 1);
           }
        </script>
 <script>



    // SETTINGS
    var SHOW_MATRICES = 1000;
    var FILE = "data/Parkinsons_Patient_RC4101_1_graphdat.json"
    var SHOW_ANTICORRELATION = false;
    var PRE_PILE = false;
    var CELL_THRESHOLD = 0.0; // only cells above are shown
    var SNAKE = true;
    var TIMELINE_HEIGHT = 180; //130; TV
    // var TIMELINE_HEIGHT = 0;
    var DIAGONAL_VALUE = 0.11;
    var SVG_MENU_HEIGHT = 30;
    var LABEL_DIST = 60;
    var LABEL_WIDTH = 130;
    // var CELL_SIZE = 10
    var CELL_SIZE = 6
    var CELL_SIZE_HALF = CELL_SIZE/2;
    var PREVIEW_SIZE = 3
    var MARGIN_TOP = 70;
    var MARGIN_BOTTOM = 30;
    var MARGIN_RIGHT = 20;
    var MARGIN_LEFT = 80;
    var MATRIX_GAP_VERTICAL = 30;
    var MATRIX_GAP_HORIZONTAL = 10;
    var PILE_TOOL_SIZE = 15
    var svg, svgTimeline, svgMenu;

    // Animation
    var FPS = 20
    var DURATION = 500


    var waitWindow // shown when server calculates similarity

    // var _courseWidth = $(window).width() - MARGIN_LEFT - MARGIN_RIGHT; 
    // var _courseHeight = $(window).height() +200//- MARGIN_LEFT - MARGIN_RIGHT; 
    var _courseWidth = $(window).width() - 40 
    var _courseHeight = $(window).height() 

    var dynamicdata;
    var graphMatrices // graph matrices
    var adjacentDistances;
    var maxDistance = 0;
    var pilingMethod = 'clustered'
    var matrixStrings = ''

    var piles = []; // contains all piles. Each pile contains matrices, not indices
    var matrixPos = []; // index of pile in layout array
    var matrices = []; // contains all matrices 
    var matricesPileIndex = []; // contains pile index for each matrix. 
	
	// TV a pile of consensus matrices
	var consensus = [];
	var consensusPile; //TV = new Pile(0, scene, allPileOrdering[orderMenu.selectedIndex], _zoomFac);	
		

    var hoveredMatrix;
    var draggingMatrix; // index of currently dragged matrix (for matrices[])
    var selectedMatrices = [];
    var dragActive = false;
    var hoveredGapPile = undefined
    var openedPileRoot = undefined
    var openedPileMatrices = []

    var activePile; // pile that contains last mouse hovered matrix
    var activeMatrixInPileIndex; // index of last hovered matrix in pile
    var matrixGapMouseover = false;

    var timeline;

    var nodes = []; 
    var focusNodes = [] // currently visible nodes (changed by the user)
            
    var _matrixWidth
    var _matrixWidthHalf

    var rightClick = false;

    var _cols;

    var shiftDown = false;

    var _isLoadedSession = false
    var _isSavedSession = false

    // var START_ROW = 0;
    // var END_ROW = 0;
    // var START_COL = 0;
    // var END_COL = 0;

    var MODE_SUMMARY = 0
    var MODE_BARCHART = 1
    var MODE_TREND = 2
    var MODE_VARIABILITY = 3
    var MODE_DIFFERENCE = 4
    var MODE_DIRECT_DIFFERENCE = 5

    var ORDER_DATA = 0
    var ORDER_GLOBAL = 1
    var ORDER_LOCAL = 2
    var orderMenu = document.getElementById('allNodeOrder')
	var sortMenu = document.getElementById('allSort')
    var coverMatrixMenu = document.getElementById('allCover')
    var allPileOrdering = []
    var focusNodeAllPileOrdering = [] // array containing the orderings for all piles, when not all nodes are focused on

    var _zoomFac = 1

    var slider;

    var pileIDCount = 1; //TV changed from 0 to allocate 0 to consensus pile

    var startPile = 0;
    // var this.zoomedMatrix = null;

    var maxValue = 0


    var cellValue = d3.scale
    	.linear()
        // .log()
        .range([0,1])
        .nice()
        
    var SESSION_NAME;

    // var _pileToolsVisible = true


    labelTextSpec.size = CELL_SIZE-1

    // Load available files
    // var csvRequest 
    var fileNames = [];

    $.get('data', function( data ) {
        var list = data.split('href="') 
        for(var i=0 ; i<list.length ; i++){
            if(list[i].indexOf('.dyjson') == -1) continue
            $("#fileSelection")
                .append('<option>data/' + list[i].split('"')[0] + '</option>')
        }
    });


    // If the user changes the focus nodes, matrix similarity must be recalculated before automatic piling. Distance calculation is performed on the server. 
    var dMat = [];
    var pdMat = []; // contains similarity between piles
    var pdMax = 0;
    var pileDistanceColor // value range for similarity 

	//TV: connectivity does not take into account autocorrelation
	var connectivity = []
	var COLOUR = ['#000000','#8dd3c7','#fb8072','#80b1d3','#fdb462','#fccde5','#ccebc5','#bc80bd','#ffed6f','#d9d9d9','#ffffb3','#bebada']
	
    retrieveSessions();


    // find an ordering for all nodes that shows clustering across the 
    // sum of all individual time step matrices.
    function calculateGlobalOrder(graph) {
        var max = 0;
        var globalMatrix = [];
        for (var i=0 ; i<graph.times[0].matrix.length ;i++) {
            globalMatrix[i] = [];
            //TV for (var j=0 ; j< graph.times[0].matrix[i].length; j++) {
			for (var j=0 ; j< graph.times[0].matrix.length; j++) {
                globalMatrix[i][j] = 0;
            }
        }

        for (var t=0 ;t < Math.min(SHOW_MATRICES,graph.times.length) ;t++) {
            for (var i=0 ;i < graph.times[t].matrix.length ;i++) {
                //TV for (var j=0; j < graph.times[t].matrix[i].length ;j++) {
				for (var j=0; j < graph.times[t].matrix.length ;j++) {
					//console.log(graph.times[t].matrix[i].length);
					for (var ml=0; ml < graph.times[t].matrix[i].length; ml++){
						if(graph.times[t].matrix[i][ml][j] > CELL_THRESHOLD){
							// graph.times[t].matrix[i][j]++
							// graph.times[t].matrix[j][i]++
							globalMatrix[i][j] += Math.abs(graph.times[t].matrix[i][ml][j])
							//TV globalMatrix[j][i] += Math.abs(graph.times[t].matrix[j][i])
							max = Math.max(max, graph.times[t].matrix[i][ml][j]);
						}
					}
                }
            }
        }
        // CELL_THRESHOLD++
        cellValue.domain([CELL_THRESHOLD, max])

        // 2) Reorder
        var leafOrder = reorder.leafOrder()
          .distance(science.stats.distance.manhattan)(globalMatrix);

        var order = []
        leafOrder.forEach(function (lo, i) {
            order[i] = lo;
        });

        return order;
    }

    function init(){

        FILE = location.search.split('data=')[1]

        var d=new Date();
        SESSION_NAME = FILE + "-" 
            + d.getDate() 
            + "/" + (d.getMonth()+1) 
            + "/" + d.getYear() 
            + "-" + d.getHours() + ":" + d.getMinutes();

        loadFile(FILE)
    }

    function exportSession(){

        if(!SESSION_NAME){
            var menu = $('#sessionSelection')[0];
            SESSION_NAME = menu.options[menu.selectedIndex].text;
        }
        // save before export
        saveSession()

        var dump = getSessionDump(SESSION_NAME);
        var url = 'data:text/json;charset=utf8,' + encodeURIComponent(dump);
        window.open(url, '_blank');
        window.focus();
    }
    
    function exportPileMeasures(){
        var mean
        var dump = ""
        dump += '"Data name "' + SESSION_NAME + '\n'
        dump += '"Number of piles", ' + piles.length + '\n'
        for(var p=0 ; p<piles.length ; p++){
            mean = 0
            for(var t=0 ; t<piles[p].size() ; t++){
                for(var i=0 ; i<nodes.length ; i++){
                //TV for(var j=i ; j<nodes.length ; j++){
					for(var j=0 ; j<nodes.length ; j++){
						console.log(graph.times[t].matrix[0].length);
						for (var ml=0; ml < graph.times[t].matrix[0].length; ml++){
							mean += piles[p].getMatrix(t).matrix[i][ml][j] 
					   }
                    }
                }
            }
            mean /= ((nodes.length * nodes.length + nodes.length) / 2) * piles[p].size()
            dump += '"Pile ' + p + '", ' + piles[p].size() + ', ' + mean + '\n'
        } 

        var url = 'data:text/csv;charset=utf8,' + encodeURIComponent(dump);
        
        window.open(url, '_blank');
        window.focus();
    }

    


    // WebGL setup: 
    // _courseHeight = 5000
    var scene = new THREE.Scene();
    var w = _courseWidth;
    var h = _courseHeight;
    var camera = new THREE.OrthographicCamera(
            _courseWidth / - 2, 
            _courseWidth / 2, 
            _courseHeight / 2, 
            _courseHeight / - 2, 
            1, 11) 
    scene.add(camera); 
    camera.position.z = 10;
    camera.position.x = _courseWidth/2 - 120; //TV was -50 leave more space for user defined consensus pile.
    var topScrollLimit = MARGIN_TOP -_courseHeight/2
    camera.position.y = topScrollLimit - 60; //TV added -60 to leave less space from the histogram

    var renderer = new THREE.WebGLRenderer({antialias: true})
    renderer.setSize(_courseWidth, _courseHeight)

	renderer.setClearColor( 0xffffff, 1);
    //TV renderer.setClearColor( 0xffffff, 1);
    var canvas = renderer.domElement;
    canvas.addEventListener('click', function(e){
        clickCanvas(e)
    })
     canvas.addEventListener('dblclick', function(e){
         doubleClickCanvas(e)
     }) //TV on double click add/remove matrix/pile in/from the consensus pile and annotate addition/deletion in timeline adding a dot over the score bar.
    //TV canvas.addEventListener('mousedown', function(e){
    //TV     canvasMouseDown(e)
    //TV })
    //TV canvas.addEventListener('mouseup', function(e){
    //TV     canvasMouseUp(e)
    //TV })
    canvas.addEventListener('mousemove', function(e){
         mouseMove(e)
     })
     canvas.addEventListener('mousewheel', mouseWheelChanged, false );


    var origin = new THREE.Vector3()
    var raycaster = new THREE.Raycaster()
    var pileMeshes = []


    init()
    
    function render(){

        var d = new Date();
        var begin = d.getTime()
        renderer.render(scene, camera)
        d = new Date();
        // console.log('>>>> RENDERED ', (d.getTime() - begin), ' ms.')
        for(var i=0 ; i<visiblePileTools.length ; i++){
        	scene.remove(visiblePileTools[i])
        }
    }

    function loadFile(file){
    
        console.log('loadFile')
        $('#pilesPlot').append(canvas)

        // $('#sessionName').val(SESSION_NAME)
        SNAKE = false
        FILE = file;

        console.log(file);
        $('#menuLoadData').remove();
        $('#sessions').css({ opacity: 1});


        d3.json(file,function (graph) 
        {

			svgTimeline = d3.select("#chartTimeline")
                .append("svg")
                .attr("width", _courseWidth)
                .attr("height", TIMELINE_HEIGHT + 52); //20);  TV

				console.log("t");

			// TV sort matrices on scores rather than as they appear in JSON 
			//console.log(graph.times[0]);
			console.log(document.getElementById("sort_run_id").checked);
			setOrder();
			//TV if (document.getElementById("sort_asc").checked)
			//TV {
			//TV 	graph.times = graph.times.sort(function(x, y){
			//TV 		return d3.ascending(x.score, y.score);
			//TV 	})
			//TV } 
			if (document.getElementById("sort_desc").checked)
			{
				graph.times = graph.times.sort(function(x, y){
					return d3.ascending(y.score, x.score);
				})
			} else if (document.getElementById("sort_iteration").checked)
			{
				graph.times = graph.times.sort(function(x, y){
					return d3.ascending(y.iteration, x.iteration);
				})
				graph.times = graph.times.sort(function(x, y){
					return d3.ascending(x.run_id, y.run_id);
				})
			}

            // READ DATA
            dynamicdata = graph;

            nodes = graph.nodes;
    		var s
            for(var i=0 ; i<nodes.length ; i++){
                focusNodes.push(i)
		        s = nodes[i].name  +''
		        nodes[i].name = s.trim()
            }

			// TV matrices stored in an array 
            graphMatrices = []     
            for(var i=0 ;i<graph.times.length && i<SHOW_MATRICES;i++){
                graphMatrices.push(graph.times[i].matrix)
            }

			//TV also store scores in an array needed in timeline.js
			graphScores = []
			for(var i=0 ;i<graph.times.length && i<SHOW_MATRICES;i++){
                graphScores.push(graph.times[i].score)
            }

			// TV TODO: update to consider the full matrix not just upper triangle
            calculateDistanceMatrix()
            
            // INIT LAYOUT
            var n = graph.nodes.length;
            _matrixWidth = n * CELL_SIZE;
            _matrixWidthHalf = _matrixWidth/2;

            highlightFrame = GLUtils.createRectFrame(_matrixWidth, _matrixWidth, 0xff8100, 10)



            _cols = Math.floor(
                (_courseWidth - MARGIN_LEFT - MARGIN_RIGHT) / (_matrixWidth + MATRIX_GAP_HORIZONTAL)
            )-1
            // console.log('cols',_cols)
            // _cols = 12
            END_ROW = n-1;
            END_COL = n-1;

            allPileOrdering[ORDER_DATA] = []
            allPileOrdering[ORDER_GLOBAL] = []
            for(var i=0 ; i<nodes.length ; i++){
                allPileOrdering[ORDER_DATA].push(i)
            }

            allPileOrdering[ORDER_GLOBAL] = calculateGlobalOrder(graph);
          
            var menuX = MARGIN_LEFT;

            // svg = d3.select("#pilesPlot")
            //     .append('svg')
            //     .attr("width", _courseWidth)
            //     .attr("height", 50)

            // INIT PILES (each single matrix is a pile)
            if (PRE_PILE) {
                for (var i = 0; i < graph.clusters.length; i++)
                    piles.push(new Pile(pileIDCount++, scene, allPileOrdering[orderMenu.selectedIndex], _zoomFac));
                // calculatePiles();
            } else if (false) { // TV a pile is created for each matrix 
                for (var i = 0; i < Math.min(SHOW_MATRICES, graph.times.length) ; i++) {
                    var p = new Pile(pileIDCount++, scene, allPileOrdering[orderMenu.selectedIndex], _zoomFac);
                    piles.push(p);
                }
            } else { // TV a pile is created for each matrix 
                for (var i = 0; i < Math.min(SHOW_MATRICES, graph.times.length) ; i++) {
					//for (var i = 0; i < graph.run_id.length; i++)
                    var p = new Pile(pileIDCount++, scene, allPileOrdering[orderMenu.selectedIndex], _zoomFac);
                    piles.push(p);
                }
            }
             
           
            // INIT MATRICES
            for (var t = 0 ; t < Math.min(SHOW_MATRICES, graph.times.length) ; t++) {
                // Obtain pile for new matrix
                var p = piles[t]
                if(PRE_PILE){
                    for (var i = 0; i < graph.clusters.length; i++){
                        if(graph.clusters[i].indexOf(t) > -1){
                            p = piles[i];
                            break;
                        }
                    }
                }
				//TV console.log(graph.times[t].score);
				//TV this is where the matrices from the data graph.times[t].matrix are loaded to the collection of piles: p = piles[t]
                // Create matrix
                var matrix = new Matrix(
                    t, 
					graph.times[t].run_id,
                    graph.times[t].matrix,
					graph.times[t].score, //TV score added as an attribute of every Matrix
					graph.times[t].iteration // TV iteration added as an attribute of every Matrix (prob not used)
                    )
				//TV except from the collection of piles: p, it seems that the matrix object is also added in the local data array: matrices
                matrices.push(matrix);
                p.addMatrices([matrix]);
                p.draw()
            }

            updateLayout(0, false);

            // CREATE TIMELINE
            timeline = new Timeline();
            timeline.updateLayout();
            timeline.updateNodeOrder(allPileOrdering[orderMenu.selectedIndex]);


            if(_isLoadedSession)
                finalizeLoadSession()

            // create wait window    
            waitWindow = svgTimeline.append('g')
                .attr('id', 'waitWindow')
                .attr('transform', 'translate('+(_courseWidth/2 -200) + ',' +20 + ')')

            waitWindow.append('rect')
                .attr('x', 0).attr('y', 0)
                .attr('width', 400)
                .attr('height',100)
                .style('fill', '#fff')
                .style('stroke', '#000')
                .style('opacity', .98);

            waitWindow.append('text')
                .attr('x', 100)
                .attr('y', 40)
                .attr('class', 'infotext')
                .text('Please wait ...')

            showWait(false)

			//TV
			this.consensusPile = new Pile(0, scene, allPileOrdering[orderMenu.selectedIndex], _zoomFac);	
			
            // RENDER
            render()
     
            savePilingHistory()

            // selectNodes()
            // calculatePrecisePiling()
            // exportPileMeasures()
			
			//TV
			calculateConnectivity();
			//TV
			updateConnectivity(0);
        }); // TV ENDOF d3.json(file)
    } // TV ENDOF loadFile(file)

    var highlightFrame 
			
	//TV variable for the grid
	var gridFrame
	var dotmesh

    function highlightPile(pile){
        highlightFrame.position.set(pile.x, pile.y, 0)
        highlightFrame.visible = true
        scene.add(highlightFrame)
    }
    function highlightNoPile(){
        scene.remove(highlightFrame)
		//TV TODO also set opacity to 1 for all timelineMatrix_id
		d3.selectAll(".timelineMatrix")
			//.transition()
			.style("opacity", 1);
			//.attr('opacity', 1)
    }

	function removeGridFrame(){
		scene.remove(gridFrame)
		render()
	}
	
	function removeDotMesh(){
		scene.remove(dotmesh)
		render()
	}

    function focusOn(nodes){
    	focusNodes = nodes

    	// update sizes
		_matrixWidth = CELL_SIZE * focusNodes.length  	
		_matrixWidthHalf = _matrixWidth/2  	
 	 	// _cols = Math.floor((_courseWidth- MARGIN_RIGHT) / (_matrixWidth + MATRIX_GAP_HORIZONTAL))
        _cols = Math.floor((_courseWidth - MARGIN_LEFT - MARGIN_RIGHT) / (_matrixWidth + MATRIX_GAP_HORIZONTAL))-1
		calculateDistanceMatrix()
          
 	 	// update highlight frame
		scene.remove(highlightFrame)
		highlightFrame = GLUtils.createRectFrame(_matrixWidth, _matrixWidth, 0x000000, 10)
		scene.add(highlightFrame)

		// redraw
		for(var i=0 ; i<piles.length ; i++){
			piles[i].updateFrame()
		}
		
		consensusPile.updateFrame()
		
		redrawPiles(piles)
    	this.updateLayout(0, true)
		render()


    }


    function calculateDistanceMatrix(){
        dMat = []
        
		var data = pileUtils.calculateDistance(graphMatrices, focusNodes)
        dMat = data.distanceMatrix
        pdMat = data.distanceMatrix
        maxDistance = data.maxDistance;
        pdMax = maxDistance // initialize 
        // pileDistanceColor.domain([0,pdMax])

        // ADD SLIDER
        if(slider)
            slider.destroy()
        slider = new Slider(svgTimeline, TIMELINE_HEIGHT, 0, maxDistance);  

        setPileSliderTick(0.25, graphMatrices)
        setPileSliderTick(0.5, graphMatrices)
        setPileSliderTick(0.75, graphMatrices)
    }

    function setPileSliderTick(frac, matrices){
        var value = maxDistance * frac
		var piling = pileUtils.calculateClusterPiling(maxDistance * frac, matrices, dMat)
		var label = (maxDistance * frac).toFixed(2) + ' (' + (piling.length) + ')'
        slider.setTick(label, maxDistance * frac)

    }

    function calculatePrecisePiling(){
        var value = parseFloat($('#precisePilingValue').val())
        calculatePiles(value)
        slider.setSliderKnob(value)
    }

    function selectNodes(){
	    var value = $('#filteredNodes').val()
	    var desiredNodes = value.split(',')
		for(var i=0 ; i<desiredNodes.length ; i++){
			desiredNodes[i] = desiredNodes[i].trim()
		}
	    var newNodes = []
        for(var i=0 ; i<nodes.length ; i++){
        	for(var j=0 ; j<desiredNodes.length ; j++){
        		if(desiredNodes[j] == nodes[i].name)
        			newNodes.push(i)
        	}
        }
        focusOn(newNodes)
    }

    function showWait(b){
        if(b){
            svgTimeline.append(function () { return waitWindow[0][0] }) 
        }else{
            d3.select('#waitWindow').remove();            
        }
    }

    ////////////////////////////////
    /// PILING

    var pilingAnimations = []
    var interval
    /* Starts all animations in pilingAnimations array.*/
    function startAnimations(){
        console.log('----> START ANIMATIONS')
        clearInterval(interval)                
        interval = setInterval(function(){
            for(var i=0 ; i<pilingAnimations.length ; i++){
                pilingAnimations[i].step()
                if(pilingAnimations[i].done)
                    pilingAnimations.splice(i,1)
            }
            if(pilingAnimations.length == 0){
                clearInterval(interval)
                interval = undefined
                updateLayout()
                pilingAnimations = []
                savePilingHistory()
                console.log('----> ANIMATIONS DONE')      
            }
            render() 
        }, 500/FPS)
    }

    /** Piles a set of matrices onto a target pile 
    removes it from source pile, and 
    updates the layout. 
    If animated=true, a PilingAnimation is created and stored
    in the pilingAnimations array. Animations are started by
    calling startPilingAnimations()
     */
    function pile(mats, targetPile, animate)
    {   
        if(!animate) animate = false
        if(animate){
            pilingAnimations.push(new PilingAnimation(targetPile, mats))
        }else{
            var matricesToPile = mats.slice(0); 
            var insertIndex;
            var pos;
            var m;
            var sourcePile, spi; // source-pile-index
            var sourcePiles = []
            for (var i = 0; i < matricesToPile.length; i++)
            {
                m = matricesToPile[i]; 
                sourcePile = m.pile;
                sourcePile.removeMatrices([m]);
                if(sourcePile.size() == 0 && sourcePile != targetPile){
                    destroyPile(sourcePile)
                }
            }


            targetPile.addMatrices(matricesToPile);
            sortTime(targetPile)

            redrawPiles(piles)
            updateLayout(0, true)
            timeline.updateLayout();    
            render()
        }
    }


    /*Piles all matrices prior to the selected one, including the selected one.*/
    function pileBackwards(p)
    {
        var i = piles.indexOf(p)
        var mats = []
        var num
        if(p.size() == 1){
	        // console.log('pile matrices')
	        for(var j=i ; j>=0 ; j--){
	            if(j==0 || piles[j-1].size() > 1){
	                pile(mats, piles[j], $('#animateCheckBox').is(':checked'))
                    startAnimations()
	                return
	            }else{
	                mats.push.apply(mats, piles[j].getMatrices())
	            }
	        }
    	}else{
    		if(piles.indexOf(p) > 0){
	    		pile(p.pileMatrices, piles[piles.indexOf(p)-1], $('#animateCheckBox').is(':checked'))
   			}
    	}
        startAnimations()

    }

    function depile(pile, animated){
        var startPos = {x:0, y:0} 
        var newPiles = []

        if(animated){
            startPos.x = pile.x
            startPos.y = pile.y
        }
       var mats = [];
        var ix = piles.indexOf(pile);
        mats.push.apply(mats, pile.pileMatrices)
        if(mats.length == 1) return;

        for(var i=mats.length-1 ; i>0 ; i--){
            pile.removeMatrices([mats[i]])                           
            var pNew = new Pile(pileIDCount++, scene, allPileOrdering[orderMenu.selectedIndex], _zoomFac);
            pNew.colored = pile.colored;
            piles.splice(ix+1, 0, pNew);

            pNew.addMatrices([mats[i]])

            pNew.draw();

            newPiles.push(pNew)
        }

        if(orderMenu.selectedIndex == ORDER_LOCAL)
            pile.setNodeOrder(pile.calculateLocalOrder())
        
        pile.draw()
        this.updateLayout(0, true);
        timeline.updateLayout();
        
        if(animated){
            console.log('depile animated')
            pilingAnimations.push(new DepileAnimation(newPiles, startPos))
            startAnimations()               
        }
        
        render()

    }


   
    // Splits a pile at the position of the passed matrix. 
    // The passed matrix becomes the base for the new pile 
    function splitPile(matrix, animated)
    {
        console.log('split pile', animated)
        if(!animated){
            var pSource = matrix.pile;
            var pNew = new Pile(pileIDCount++,scene, allPileOrdering[orderMenu.selectedIndex], _zoomFac);
            pNew.colored = pSource.colored;
            piles.splice(piles.indexOf(pSource)+1, 0, pNew);

            var m = [];
            for(var i=pSource.getMatrixPosition(matrix) ; i<pSource.size() ; i++){
                m.push(pSource.getMatrix(i))
            }

            pile(m, pNew);
            updateLayout(piles.indexOf(pNew)-1, true);
            if(orderMenu.selectedIndex == ORDER_LOCAL)
                pNew.setNodeOrder(pNew.calculateLocalOrder())

			//TV
			console.log("a pile is split in two")	
			pSource.showSingle(undefined)		
				
            pNew.draw();
            pSource.draw();	

            render()
            savePilingHistory()
        }else{
            pilingAnimations.push(new SplitAnimation(matrix))
            console.log('split pile animated:')
            startAnimations()               
        }
		allCoverChanged() //TV added
    }



    function removeFromPile(pile){

    }

    function deselectAllMatrices()
    {
        for(var i in selectedMatrices)
        {
            selectedMatrices[i].frame.attr("class", "matrixbackground")
        }
        selectedMatrices = [];
    }


    // Update layout depending on order of piles in piles array.
    // Starts updating at pileIndex.
    var PILING_DIRECTION = 'vertical'
    // var PILING_DIRECTION = 'horizontal'
    function updateLayout(pileIndex, animate)
    {
		var pos, p;
	    if(PILING_DIRECTION == 'vertical'){
	        for(var i=pileIndex ; i<piles.length ; i++){
	            p = piles[i];

	            pos = getLayoutPosition(i);
	            p.moveTo(pos.x, pos.y, false)
	        }
     	}else{
     	    var px
	        for(var i=pileIndex ; i<piles.length ; i++){            
	            p = piles[i];
	            pos = this.getLayoutPosition(i);
	            px = pos.x;
	            py = pos.y;
	            p.moveTo(pos.x, pos.y)
	        }
     	}
    }

 

    // index indicates the matrix index, not its position 
    // in the layout
    function getMatrixPosition(matrixIndex)
    {
        return getLayoutPosition(matrixPos[matrixIndex])
    }

    function getLayoutPosition(index)
    {
    	if(PILING_DIRECTION == 'horizontal'){
    		var x=MARGIN_LEFT, y=MARGIN_TOP;
	        for(var i=0 ; i<index ; i++){
	            x += _matrixWidth + (piles[i].size()*2) + MATRIX_GAP_HORIZONTAL + 10
	            if((x+_matrixWidth + (piles[i].size()*2) + MATRIX_GAP_HORIZONTAL) > _courseWidth){
	                x = _matrixWidth;
	                y += _matrixWidth + MATRIX_GAP_VERTICAL; 
	            }
	        }
	        return {x: x, y: y}
    	}
		else{
			var col = Math.floor(index % _cols);
        
	        var y = MARGIN_TOP
	        var currh = 0
	        var temp  
	        for(var i=0; i<piles.length; i++)
	        {   
	            if(i>0 && i % _cols == 0){ // when new row starts
	                if(i>index){
	                    break;
	                }else{
	                    y += currh + _matrixWidth + MATRIX_GAP_VERTICAL;
	                    currh = 0;
	                }
	            }
	            temp = piles[i].size() * 2 //2 = preview height
	            if(temp > currh){
	                currh = temp
	            }
	        }

            return {
	            x: MARGIN_LEFT + col * (_matrixWidth + MATRIX_GAP_HORIZONTAL) + _matrixWidthHalf, 
	            y: y + currh}
			}    
    }

    // Sorts matrices in pile according to time
    function sortTime(pile){
        pile.pileMatrices.sort(matrixTimeComparator)
    }

    function matrixTimeComparator(a,b){
        return parseInt(a.id) - parseInt(b.id); 
    }   

    function hidedistance(){
        for(var i in matrices){
            matrices[i].g_course.style("opacity", "1") 
        }
    }

 
    function setPileMode(mode, piles)
    {
        for(var i=0; i < piles.length; i++) 
            piles[i].setCoverMatrixMode(mode);
    }

    function setSimilarityPiling(value){
         calculatePiles(value);
    }

    function destroyPile(p){
		p.destroy()
        var i = piles.indexOf(p)
        piles.splice(i,1)
        if(previousHoveredPile == p)
        	previousHoveredPile = undefined
        if(hoveredGapPile = p)
        	hoveredGapPile = undefined 
    }

    function calculatePiles(value)
    {
        showWait(true);
        setSliderActive(false)
        var newpiling = pileUtils.calculateClusterPiling(value, matrices, dMat)

        var label = value.toFixed(2).toString() + ' (' + (newpiling.length) + ')'
        slider.setSliderLabel(label) 

        setPiling(newpiling)                    
        savePilingHistory()
    
    }

    function getCurrentPiling(){
        var piling = []
        for(var i=0 ; i<piles.length ; i++){
            piling.push(matrices.indexOf(piles[i].getMatrix(0)))
        }       
        // console.log('currentPiling', piling)

        return piling 
    }

    function setPiling(newpiling){
        console.log('setPiling', newpiling)
        for(var i=0 ; i<piles.length ; i){
            destroyPile(piles[i])
        }

        piles = [];
        
        var mats = []
        var l=0
        var p 
        // remove all previous piles
        // for(var i=0 ; i<piles.length ; i){
        //     piles[i].destroy()
        // }
        for(var i=1 ; i<=newpiling.length ; i++){
            mats = [];
            if(i<newpiling.length){
                for(var j=l ; j<newpiling[i] ; j++){
                    mats.push(matrices[j])
                }
            }else if(l < matrices.length){
                for(var j=l ; j<matrices.length ; j++){
                    mats.push(matrices[j])
                }                
            }else{
                break;
            }
            p = new Pile(pileIDCount++, scene, allPileOrdering[orderMenu.selectedIndex], _zoomFac)
            piles.push(p);
            p.addMatrices(mats)
            if(orderMenu.selectedIndex == ORDER_LOCAL)
                p.setNodeOrder(p.calculateLocalOrder())
            sortTime(p)            
            p.setCoverMatrixMode(coverMatrixMenu.selectedIndex);
            p.draw()
            l = newpiling[i];
        }


        updateLayout(0, false);
        timeline.updateLayout(0,false);
        setSliderActive(true)
        showWait(false);
    
        render()
    }

    function showTools(pile) {
        // // console.log(piles.indexOf(pile))
        // pileTools.pile = pile; 
        // var tools = this.svg.selectAll(".pileTools")
        //     .data(pileTools.filter(function(d,i){
        //         return d.single || pile.size() > 1;}));
       
        // var added = tools.enter().append('g')
        //     .style('opacity', 0)
        //     .attr('class', 'pileTools');
        // added
        //     .append("rect")
        //     .attr('width', 15)
        //     .attr('height', 15)
        //     .attr('rx', 3)
        //     .attr('ry', 3)
        //     .attr('fill', function (d) {
        //         return d.color;
        //     })
        //     .on('mouseover', function () {
        //         pileTools.mouseover = true;
        //         tools.style('opacity', 1);
        //     })
        //     .on('mouseout', function () {
        //         pileTools.mouseover = false;
        //         tools.style('opacity', 0);
        //         hideTools(pileTools.pile.svg)
        //     })
        //     .on('click', function (d) {
        //         d.doit([pileTools.pile], piles);
        //     });
        // added.append('title').text(function (d) { return d.name; });
        // added.append('text')
        //     .attr('class','toolLabel')
        //     .attr('fill', 'white')
        //     .attr('pointer-events','none');

        // // tools.select('rect')
        // //     .attr('x', function (d, i) {
        // //         var x = pileTools.pile.x + pileTools.pile._matrixWidth - (i + 1) * 15;
        // //             return x;
        // //         })
        // //     .attr('y', this.y + this._matrixWidth);
        
        // // tools.select('text')
        // //     .attr('x', function (d, i) {
        // //         var x = pileTools.pile.x + pileTools.pile._matrixWidth - (i + 1) * 15 + 4;
        // //         return x;
        // //     })
        // //     .attr('y', this.y + this._matrixWidth + 10)
        // //     .text(function(d) { return d.name[0] })

        // tools.select('rect')
        //     .attr('y', pile.y + this._matrixWidth)
        //     .attr('x', function(d,i){ 
        //         return pile.x + (i * 15)});
        
        // tools.select('text')
        //     .attr('y', function (d, i) {
        //         var y = pile.y + pile._matrixWidth +12 ;
        //         return y;
        //     })
        //     .attr('x', function(d,i){ return pile.x + i*15 +3})
        //      .text(function(d) { return d.shortCut })

        // tools.transition()
        //     .style('opacity', 1);
    }

    function isSameOrdering(o1, o2){
        
        if(!o1 || !o2) return false
        if(o1.length != o2.length) return false

        var same = true;
        for(var i=0 ; i<o1.length ; i++){
            if(o1[i] != o2[i]){
                same = false;
                break
            }
        }
        return same;
    }


    function distance(m1, m2, focusNodes){
        var d = 0; 
        var a, b;
        for(var i=0 ; i<focusNodes.length ; i++){
            a = focusNodes[i]
			for(var j=0 ; j<focusNodes.length ; j++){
            //TV for(var j=i ; j<focusNodes.length ; j++){
                b = focusNodes[j]
                d += Math.pow(m1.matrix[a][b] - m2.matrix[a][b],2)
            }
        }
        return Math.sqrt(d);
    }

    function setNodeOrder(piles, order){
        for(var i=0 ; i<piles.length ; i++){
            piles[i].setNodeOrder(order);
        }
		consensusPile.setNodeOrder(order)
    }

    function setPilingMethod(method){
        pilingMethod = method;
        if(slider)
            slider.destroy()
        slider = new Slider(svgTimeline, TIMELINE_HEIGHT, 0, maxDistance);  

        setPileSliderTick(0.25, matrixStrings)
        setPileSliderTick(0.5, matrixStrings)
        setPileSliderTick(0.75, matrixStrings)
    }

    // takes a seed pile and shows how similar
    // all the other piles/matrices are. 
    // the similarity between two piles is the
    // mean of the distances between all matrices 
    // from p1 to all matrices to p2 (bigraph) 
    function showMatrixSimilarity(pile){
        var d;
        var i = piles.indexOf(pile)
        for(var j=0 ; j<piles.length; j++){
            piles[j].showSimilarity(pileDistanceColor(pdMat[i][j]))
        }
    }
    function unshowMatrixSimilarity(){
        var d;
        for(var j=0 ; j<piles.length; j++){
            piles[j].resetSimilarity()
        }
    }


    // function doubleClickCanvas(e){
    // 	e.preventDefault();

    // 	if(hoveredPile && hoveredPile != openedPile){
    //         openedPileRoot = hoveredPile
    // 		var p = hoveredPile
    // 		hoveredPile = undefined
    // 		depile(p, $('#animateCheckBox').is(':checked'))

    // 	}else{
    //         openedPile = hoveredPile
    //         var p = hoveredPile
    //         hoveredPile = undefined
    //         depile(p, $('#animateCheckBox').is(':checked'))    
    //     }

    // }


	// TV add/remove pile from consensus pile and update annotation in timeline view
	function doubleClickCanvas(e)
	{
		console.log("dbClick!")

		//if(mouseDown)
		//	return	

		if(hoveredTool){
			console.log("hoveredTool")
            //hoveredTool.doit(piles, hoveredTool.pile)
            //render()
            //hoveredTool = undefined
        }else
        if(hoveredGapPile){
			console.log("hoveredGapPile")
            //var p=hoveredGapPile
            //hoveredGapPile = undefined
            //pileBackwards(p)
            //savePilingHistory()

        }else
        if(hoveredMatrix){
			console.log("hoveredMatrix")
            //var p=hoveredMatrix
        	//hoveredMatrix = undefined
            //splitPile(p,$('#animateCheckBox').is(':checked'))
            //savePilingHistory()
			//allCoverChanged() //TV added
        }			
	}


    // CANVAS MOUSE INTERACTION

    function clickCanvas(e){

		if(mouseDown)
			return	
	
        if(hoveredTool){
            hoveredTool.doit(piles, hoveredTool.pile)
            render()
            hoveredTool = undefined
        }else
        if(hoveredGapPile){
            var p=hoveredGapPile
            hoveredGapPile = undefined
            pileBackwards(p)
            savePilingHistory()

        }else
        if(hoveredMatrix && !hoveredMatrix.pile.inConsensus())//id != 0)) // and is not the consensusPile ) TV prevents splitting consensusPile (BUG). However this also restricts splitting piles which contain nets in consensusPile. First those nets get removed and then split can happen.
		{
			console.log("hoveredMatrix.pile.id = ", hoveredMatrix.pile.id)
            var p=hoveredMatrix
        	hoveredMatrix = undefined
            splitPile(p,$('#animateCheckBox').is(':checked'))
            savePilingHistory()
			//allCoverChanged() //TV added
        }
		else if(hoveredPile && (hoveredPile.id != 0)) // and is not the consensusPile 
		{
			//if (hoveredPile.id == 0) // then consensusPile is hovered
			//	break;
				
			//console.log("Εδω βαλε")
			console.log("On canvas click if hoveredPile add/remove whole Pile from consensus!", hoveredPile.id);
			var mats = hoveredPile.pileMatrices;
			if(!hoveredPile.inConsensus()){			 	//TV if not in, add it to the consensus
				addConsensus(mats);
				//TODO set matrices consensus status // Now done within addConsensus(mats)
				//for(i=0; i<mats.length; i++)
				//{
				//	mats[i].setConsensus(true);
				//}	
			}else{									//TV if it is in, remove it from consensus
				console.log('TODO: REMOVE FROM CONSENSUS');
				removeConsensus(mats);
			}
			timeline.updateLayout(0,false);
		}
    }

    var dragStartPos //
    var mouseDown = false
    var mouseDownTimer 
    var lassoActive = false
    var mouseWentDown = false
    function canvasMouseDown(e){
        mouseWentDown = true
    	mouseDown = true
    	dragStartPos = {
    		x: mouse.x, 
    		y: mouse.y
        }
	
        // test if mouse dwells on a matrix -> open pile
        if(hoveredPile && hoveredPile.size() > 1 && hoveredMatrix == undefined){
            console.log('dwell on matrix')
            mouseDownTimer = setInterval(function(){
                openedPileRoot = hoveredPile
                openedPileMatricesNum = hoveredPile.pileMatrices.length-1
                depile(openedPileRoot, $('#animateCheckBox').is(':checked'))
                clearInterval(mouseDownTimer)
            }, 500)            
        }
    }

    function canvasMouseUp(e){

        e.preventDefault()
        
        scene.remove(lassoObject)

        if(openedPileRoot){
            var mats = []
            var openedPileIndex = piles.indexOf(openedPileRoot)
            console.log('openedPileMatricesNum', openedPileMatricesNum)
            for(var i=0 ; i<=openedPileMatricesNum ; i++){
                mats.push(piles[openedPileIndex+i].pileMatrices[0])
            }
            pile(mats, piles[openedPileIndex], $('#animateCheckBox').is(':checked'))       
            // pile(mats, piles[openedPileIndex], true)       
            startAnimations()
            openedPileRoot = undefined
            openedPileMatricesNum = 0
        }else if(dragPile){
            // place pile on top of previous pile
            if(!hoveredPile){
                var pos = getLayoutPosition(piles.indexOf(dragPile))
                dragPile.moveTo(pos.x, pos.y, false)
                dragPile.elevateTo(0)
            }else{
                pile(dragPile.pileMatrices, hoveredPile)
                savePilingHistory()
            }
            dragPile = undefined

        }else if(lassoActive){
        	// Calculate lasso rectangle
        	if(dragStartPos){
              	scene.updateMatrixWorld();
    	        camera.updateProjectionMatrix();
    	        var x, y
        		var selectPiles = []
        		var p =-1
        		x1 = Math.min(dragStartPos.x, mouse.x)
                x2 = Math.max(dragStartPos.x, mouse.x)
                y1 = Math.min(dragStartPos.y, mouse.y)
                y2 = Math.max(dragStartPos.y, mouse.y)
                for(var i=0 ; i<piles.length ; i++){
        			x = piles[i].getPos().x
        			y = piles[i].getPos().y

        			if(x > x1 && x < x2
        			&& y > y1 && y < y2 )
        			{
        				if(p==-1) p = i
        				selectPiles.push(piles[i])
        			}
        		}
        		var matrices = []
        		// console.log(selectPiles.length)
        		for(var i=0 ; i<selectPiles.length ; i++){
        			matrices = matrices.concat(selectPiles[i].pileMatrices)	
        		}
        		if(matrices.length > 0){
    	    		// console.log('pile ',matrices.length , ' matices')
        			pile(matrices, piles[p], $('#animateCheckBox').is(':checked'))		
                    startAnimations()
        		}
        	}
        }
    	dragStartPos = undefined
        mouseDown = false
        mouseWentDown = false
        lassoActive = false
    }


    var previousHoveredPile
    var visiblePileTools = []
    var hoveredCell;
    var mouse
    var hoveredPile
    var hoverdTool
    var dragPile // pile that's first matrix is being dragged (on the dragPileDummy)
    var lassoObject
    var pileToolVisibleTimer
    function mouseMove(e)
    {
        hoveredTool = undefined
        e.preventDefault();
        hoveredMatrix = undefined

        // get mouse coordinates
        scene.updateMatrixWorld();
        camera.updateProjectionMatrix();

        mouse = new THREE.Vector3();
        var dir = new THREE.Vector3();

        mouse.set( ( e.clientX / _courseWidth ) * 2 - 1, - ( e.clientY / _courseHeight ) * 2 + 1, -1 ); // z = - 1 important!

        mouse.unproject( camera );
        
        mouse.set(
            mouse.x - canvas.offsetLeft, 
            mouse.y + canvas.offsetTop, 
            1)

        if(dragPile){
            dragPile.moveTo(mouse.x, -mouse.y, false)
            dragPile.elevateTo(.9)

            // test for hovered piles
            hoveredPile = undefined

            // No mouse down (i.e. no dragging enabled)
            // do the raycasting to find hovered elements
            dir.set( 0, 0, -1 ).transformDirection( camera.matrixWorld );

            raycaster.set( mouse, dir );

            var testPile = [piles[piles.indexOf(dragPile)-1].mesh]
            intersects = raycaster.intersectObjects(testPile);
            if(intersects.length > 0){
                hoveredPile = intersects[0].object.pile
            }

        // Test for start a new drag pile 
        }else if(mouseDown && hoveredPile && piles.indexOf(hoveredPile) > 0 && !lassoActive){
            // Don't do raycasting. "Freeze" the current state of
            // highlighte items and move matrix with cursor. 
            // console.log('hoveredMatrix', hoveredPile.id)
            dragPile = hoveredPile
            dragPile.moveTo(mouse.x, -mouse.y, false)
            dragPile.elevateTo(.9)

        }else{
            
            hoveredPile = undefined
            // No mouse down (i.e. no dragging enabled)
            // do the raycasting to find hovered elements
            
            dir.set( 0, 0, -1 ).transformDirection( camera.matrixWorld );

            raycaster.set( mouse, dir );

            // test for menu-mouse over
            // console.log('visiblePileTools', visiblePileTools.length)
            if(visiblePileTools.length > 0){
                var intersects = raycaster.intersectObjects(visiblePileTools);
                if(intersects.length > 0){
                    hoveredTool = intersects[0].object.pileTool
                    return;
                }
            }

            // test for pile mouse over
            intersects = raycaster.intersectObjects(pileMeshes);
            if(intersects.length > 0){
                var pileMesh = intersects[0].object;
                hoveredPile = pileMesh.pile
                var x = pileMesh.position.x 
                var y = pileMesh.position.y

                // TEST FOR PREVIEWS
                if(mouse.y > y + _matrixWidthHalf){
                    var d = mouse.y - (y + _matrixWidthHalf)
                    var i = Math.floor(d/PREVIEW_SIZE)
                    hoveredPile.showSingle(hoveredPile.getMatrix(i))
                    hoveredMatrix = hoveredPile.getMatrix(i)
                }else{  
                    hoveredPile.showSingle(undefined)    
                    highlightNoPile()
                }

                // TEST FOR GAPS
                if(mouse.x > x + _matrixWidthHalf){
                    hoveredGapPile = hoveredPile
                }else{
                    if(hoveredGapPile){
                        var p = hoveredGapPile
                        p.draw()
                        hoveredGapPile = undefined
                    }
                }

                // TEST FOR remove piletools from previous pile
                // if(previousHoveredPile && previousHoveredPile != hoveredPile){
                //     previousHoveredPile.updateLabels(false)   
                //     previousHoveredPile.draw()    
                // }
                
                // pileToolVisibleTimer = setInterval(function(){
                //     // _pileToolsVisible = true
                //     clearInterval(pileToolVisibleTimer)
                //     render()
                // }, 2000)
                // // pileToolVisibleTimer.start()
                // highlightPile(hoveredPile)


				//TV draw a frame to hovered pile in canvas. TODO: change opacity in linked Timeline
				if (hoveredPile.id != 0)
				{
					/* TV
					if(previousHoveredPile)
					{
						for (var i=0; i<previousHoveredPile.pileMatrices.length; i++)
						{
							document.getElementById("timelineMatrix_"+previousHoveredPile.pileMatrices[i].id).style.opacity = "1";
						}
							
					} */
					highlightNoPile()
					highlightPile(hoveredPile)	
					for (var i=0; i<hoveredPile.pileMatrices.length; i++)
					{
						//console.log("timelineMatrix_"+hoveredPile.pileMatrices[i].id)
						//console.log(document.getElementById("timelineMatrix_"+hoveredPile.pileMatrices[i].id).opacity)						
						document.getElementById("timelineMatrix_"+hoveredPile.pileMatrices[i].id).style.opacity = "0.5";
					}
					//tV previousHoveredPile = hoveredPile;
				}
				
				//timeline.updateLayout(0,false);
				
                hoveredPile.draw()         


    			hoveredCell = undefined 
                if(e.shiftKey){
        	       	// test which cell is hovered.
                    var col = Math.floor((mouse.x- (x - _matrixWidthHalf)) / CELL_SIZE)
                    var row = Math.floor(-(mouse.y - (y + _matrixWidthHalf)) / CELL_SIZE)
                    if(row >= 0 || row < focusNodes.length 
                    	|| col >= 0 || col < focusNodes.length 
                    ){
    	                hoveredPile.updateLabels(true)
    					hoveredCell = {row:row, col:col};
                    }
                }
            	for(var i=0 ; i<piles.length ; i++){
            		piles[i].updateHoveredCell()
                    piles[i].updateLabels(false)
            	}
                consensusPile.updateHoveredCell()
                consensusPile.updateLabels(false)				

                hoveredPile.updateLabels(true)
            
                if(!previousHoveredPile || previousHoveredPile != hoveredPile){
                    if(coverMatrixMenu.selectedIndex == MODE_DIRECT_DIFFERENCE){
                        redrawPiles(piles)
                    }
                }
                previousHoveredPile = hoveredPile

            }else{
                // NOTHING HOVERED
                // _pileToolsVisible = false
                visiblePileTools = []
                if(hoveredGapPile){
                    var p = hoveredGapPile
                    hoveredGapPile = undefined
                    p.draw()
                }
                if(previousHoveredPile){
                    previousHoveredPile.showSingle(undefined)
                    highlightFrame.visible = false 
                    previousHoveredPile.draw()
                    previousHoveredPile = undefined
                }
                if(coverMatrixMenu.selectedIndex == MODE_DIRECT_DIFFERENCE){
                    redrawPiles(piles)
                }
				highlightNoPile()
            }

            // Set lassoActive if user did not start mousedown on a pile but in empty 
            if(mouseWentDown){
                lassoActive = !hoveredPile
            }

            // draw lasso
            if(lassoActive){
                var x1 = Math.min(dragStartPos.x, mouse.x)
                var x2 = Math.max(dragStartPos.x, mouse.x)
                var y1 = Math.min(dragStartPos.y, mouse.y)
                var y2 = Math.max(dragStartPos.y, mouse.y)

                scene.remove(lassoObject)
                lassoObject =  GLUtils.createRectFrame(x2-x1, y2-y1, 0xff0000, 1)
                lassoObject.position.set(x1+(x2-x1)/2,y1+(y2-y1)/2, 1)
                scene.add(lassoObject)
            }
        }

        mouseWentDown = false
        render()        
    
    }

    function mouseWheelChanged(e){

        e.preventDefault();
        // if(e.shiftKey){
        //     if(e.wheelDelta > 0){
        //         _zoomFac *= 1.1
        //     }else{
        //         _zoomFac *= 0.9
        //     }

        //     // update global measures
        //     _matrixWidth = CELL_SIZE * _zoomFac * nodes.length     
        //     _cols = Math.floor(_courseWidth / _matrixWidth);

        //     highlightFrame.scale.set(_zoomFac, _zoomFac, _zoomFac)

        //     updateLayout(0, true);
        //     for(var i=0 ; i<piles.length ; i++){
        //         piles[i].scaleTo(_zoomFac)
        //     }
        //     render()

        // }
        // else{

            if(e.wheelDelta > 0){
                var y = Math.min(camera.position.y + 30, topScrollLimit)    
                camera.position.setY(y)
            }else{
                camera.position.setY(camera.position.y - 30)
            }
            render()
        // }
    }

    function allCoverChanged(){
        setPileMode(coverMatrixMenu.selectedIndex, piles)
        redrawPiles(piles)
        //TV render()
    }

    function allNodeOrderChanged(){
        console.log('allNodeOrderChanged', orderMenu.selectedIndex)

        if(orderMenu.selectedIndex == 2){ // Local
            for(var i=0 ; i<piles.length ; i++){
                piles[i].setNodeOrder(piles[i].calculateLocalOrder(), true)
            }
			consensusPile.setNodeOrder(piles[i].calculateLocalOrder(), true)
        }else{ // DATA or GLOBAL ORDERING
            setNodeOrder(piles, allPileOrdering[orderMenu.selectedIndex])
            timeline.updateNodeOrder(allPileOrdering[orderMenu.selectedIndex])
        }
    

        redrawPiles(piles)
        //TV render()

    }

    function redrawPiles(piles){
		highlightNoPile() //TV added to fix black square bug 
		removeGridFrame()
		removeDotMesh()
        console.log('redrawPiles STARTED .....')
		//TV clear canvas doesn't work:
		//context.clearRect(0, 0, canvas.width, canvas.height);
        for(var i=0 ; i<piles.length ; i++){
            piles[i].draw();
        }
//TV		if (consensusPile.pileMatrices.length > 0)
			consensusPile.draw();
		//else
			//consensusPile.destroyPile();
			
		console.log('... (rendering) ...')
		render()
		console.log('redrawPiles ENDED')
    }




    // SHADERS
    var attributes = {
       customColor: { type: 'c', value: [] }
    }
    var shaderMaterial = new THREE.ShaderMaterial({
        attributes: attributes,
        vertexShader: document.getElementById('vertexshader').textContent,
        fragmentShader: document.getElementById('fragmentshader').textContent,
        blending: THREE.NormalBlending,
        depthTest: true,
        transparent: true,
        side: THREE.DoubleSide,
        linewidth: 2
    });



    var pilingHistory = []
    var historyIndex = -1
    function savePilingHistory(){
        historyIndex++
        pilingHistory = pilingHistory.slice(0, historyIndex) 
        pilingHistory.push(getCurrentPiling())
        console.log('historyIndex', historyIndex)
    }

    function undo(){
        console.log('UNDO',historyIndex)
        if(historyIndex > 0){
            historyIndex--
            setPiling(pilingHistory[historyIndex])
        }
    }

    function redo(){
        console.log('REDO',historyIndex, pilingHistory.length)
        if(historyIndex < pilingHistory.length-1){
            historyIndex++
            setPiling(pilingHistory[historyIndex])
        }
    }

    function updateCellSize(){
        CELL_SIZE = document.getElementById("cellSizeBox").value
        console.log('new cellsize: ', CELL_SIZE)
        CELL_SIZE_HALF = CELL_SIZE/2;
        labelTextSpec.size = CELL_SIZE-1
        _matrixWidth = focusNodes.length * CELL_SIZE;
        _matrixWidthHalf = _matrixWidth/2;
        // _cols = Math.floor(
        //         (_courseWidth - MARGIN_LEFT - MARGIN_RIGHT) / (_matrixWidth + MATRIX_GAP_HORIZONTAL))-1
        _cols = Math.floor((_courseWidth - MARGIN_LEFT - MARGIN_RIGHT) / (_matrixWidth + MATRIX_GAP_HORIZONTAL)) -1
        for(var i=0 ; i<piles.length ; i++){
            piles[i].updateCellSize()
        }
		consensusPile.updateCellSize();

        console.log('_cols', _cols) 
        scene.remove(highlightFrame)
        highlightFrame = GLUtils.createRectFrame(_matrixWidth, _matrixWidth, 0xff8100, 10)
        //scene.add(highlightFrame)

        updateLayout(0, true)
        redrawPiles(piles)
        //TV render()
    }   
	
	function updateZoomPercentage(val)
	{
		document.getElementById('zoomPerc').value=val+"%"; 
	}	
	
	function updatePercentage(val)
	{
		document.getElementById('textPerc').value=val+"%"; 
	}
	
	function updateConnectivity(val)
	{
		if (val!=0)
			document.getElementById('textCon').value=val+"%"; 
		
		//TV also call focus(nodes) for those nodes which have higher connectivity than val
		var focusNodes = []
		var filterNodes = []
		for(var j=0 ; j<nodes.length ; j++)
		{
			// TV normalise connectivity thres so that the max is 100%
			//TV console.log((connectivity[j]/Math.max.apply(null, connectivity))*100, val)
			if ((connectivity[j]/Math.max.apply(null, connectivity))*100>val)
			//console.log(connectivity[j], val)
			//if (connectivity[j]>val)
				focusNodes.push(j)
			else
				filterNodes.push(j)
		}
			
		console.log('show some', focusNodes)
		focusOn(focusNodes)	
		filterOn(filterNodes)
	}
	
	function calculateConnectivity()
	{
		//TV var connectivity = []
		for (var j=0; j<nodes.length; j++)
		{
			connectivity[j] = 0
			for (var i=0; i<matrices.length; i++)
			{
				connectivity[j] = connectivity[j] + matrices[i].nodeSkeletonValues[j]*nodes.length; // matrix.length = nodes.length
				//TV console.log("con:", connectivity[j]); // display connectivity value
			}
		}
	}
	
	//TV show a list of filtered nodes
	function filterOn(_filterNodes)
	{
		document.getElementById('filteredNodesList').value=" ";
		//TV document.getElementById('filteredNodesList').placeholder="filtered nodes:";
		for (var i=0; i<_filterNodes.length; i++)
		{
			document.getElementById('filteredNodesList').value += " var"+_filterNodes[i];
			//TV document.getElementById('filteredNodesList').placeholder += " var"+_filterNodes[i];		
		}
	}
	
	//TV checkbox for skeleton mode
	function updateControls(cboxElem)
	{
		switch(cboxElem.id)
		{
			case "cbox": //TV checkbox for edge filter slider
				if (cboxElem.checked)
					document.getElementById("percentageThresSlider").disabled = false;
				else
					document.getElementById("percentageThresSlider").disabled = true;
				break;
			case "cbox2": //TV checkbox for diamond mode
				if (cboxElem.checked)
					document.getElementById("cbox3").disabled = true;
				else
					document.getElementById("cbox3").disabled = false;	
				break;
			case "cbox3": //TV checkbox for skeleton mode
				if (cboxElem.checked)
					document.getElementById("cbox2").disabled = true;
				else
					document.getElementById("cbox2").disabled = false;		
				break;
			case "cbox4": //TV checkbox for node filter slider
				if (cboxElem.checked)
				{
					document.getElementById("connectivityThresSlider").disabled = false;
					updateConnectivity(document.getElementById("connectivityThresSlider").value);
				}
				else
				{
					document.getElementById("connectivityThresSlider").disabled = true;
					updateConnectivity(0);
				}
				break;				
		}
		console.log(cboxElem.id);
	}
	
	/*TV sort on drop down list
    function sortNets()
	{
		sessionStorage.setItem("sort_id", radioElem.id);
        if(sortMenu.selectedIndex == 1){ // run_id
		}
		else if(sortMenu.selectedIndex == 2){ // run_id
		} 
		else if(sortMenu.selectedIndex == 3){ // run_id
		}
	}
	*/
	
	//TV sort depending on radio input
	function sortNetworks(radioElem)
	{
		sessionStorage.setItem("sort_id", radioElem.id);
		console.log(sessionStorage.getItem("sort_id"));
		location.reload();
		//TV redo();
		/*
		switch(radioElem.id)
		{
			case "sort_run_id":
						//alert("run id");
						// TV localStorage keeps a value after refresh
						//localStorage.setItem("option", value);
						//document.getElementById("sort_asc").checked
						break;
			case "sort_asc":
						//alert("ascending");
						
						//d3.selectAll(".colPreview")
						//.data(matrices.sort(function(x, y){
						//	return d3.ascending(x.score, y.score);
						//}))							
						break;
			case "sort_desc":
						//alert("descending");
						//document.body.innerHTML = '';
						//document.getElementById('chartTimeline').innerHTML = '';
						//document.getElementById('pilesPlot').innerHTML = '';
						//init();
						// TV sort matrices on scores rather than as they appear in JSON 
						//console.log(graph.times[0]);
						//graph.times = graph.times.sort(function(x, y){
						//	console.log(x.score);
						//	return d3.ascending(y.score, x.score);
						//})			
						break;
		}
		*/
	}
	
	function setOrder()
	{
		if (sessionStorage.getItem("sort_id") !== null)
		{
			switch(sessionStorage.getItem("sort_id"))
			{
				case "sort_run_id":
							//alert("run id");
							// TV localStorage keeps a value after refresh
							//localStorage.setItem("option", value);
							document.getElementById("sort_run_id").checked = true
							document.getElementById("sort_iteration").checked = false
							document.getElementById("sort_desc").checked = false
							break;
				case "sort_iteration":
							//alert("ascending");
							
							//d3.selectAll(".colPreview")
							//.data(matrices.sort(function(x, y){
							//	return d3.ascending(x.score, y.score);
							//}))		
							document.getElementById("sort_run_id").checked = false
							document.getElementById("sort_iteration").checked = true
							document.getElementById("sort_desc").checked = false							
							break;
				case "sort_desc":
							//alert("descending");
							//document.body.innerHTML = '';
							//document.getElementById('chartTimeline').innerHTML = '';
							//document.getElementById('pilesPlot').innerHTML = '';
							//init();
							// TV sort matrices on scores rather than as they appear in JSON 
							//console.log(graph.times[0]);
							//graph.times = graph.times.sort(function(x, y){
							//	console.log(x.score);
							//	return d3.ascending(y.score, x.score);
							//})		
							document.getElementById("sort_run_id").checked = false
							document.getElementById("sort_iteration").checked = false
							document.getElementById("sort_desc").checked = true							
							break;
			}
			
		}
	}

/*	$(function() {
		$("input[type=\"radio\"]").click(function(){
			//TV
			var value = $(this).id;
			console.log(value)
			//localStorage:
			sessionStorage.setItem("option", value);
		});
		//localStorage:
		var itemValue = sessionStorage.getItem("option");
		if (itemValue !== null) {
			$("input[checked=\""+itemValue+"\"]").click();
			//location.reload();
		}
	});
*/

    function addConsensus(_mats){
		console.log(_mats.length, 'items to add in consensus')
		for (var i=0; i<_mats.length; i++)
		{
			_mats[i].setConsensus(true);		
			this.consensus.push(_mats[i]);
			
            this.consensusPile.pileMatrices.push(_mats[i]);

        }
        this.consensusPile.singleMatrix = undefined
        this.consensusPile.REQUIRE_ORDER_UPDATE = true
        this.consensusPile.calculateGlobalMatrix()
		console.log('Size of consensus array', consensus.length);		
		//TV	this.consensusPile.addMatrices(_mats);	
		this.consensusPile.draw();
	//	updateConsensusPile();
        redrawPiles(piles)
        //    updateLayout(0, true)
        //    timeline.updateLayout();    
        //render()	
    }
	Array.prototype.remove = function() {
		var what, a = arguments, L = a.length, ax;
		while (L && this.length) {
			what = a[--L];
			while ((ax = this.indexOf(what)) !== -1) {
				this.splice(ax, 1);
			}
		}
		return this;
	};
	function removeConsensus(_mats){
		console.log('TODO remove from consensus items', _mats.length);
		for (var i=0; i<_mats.length; i++)
		{
			for (var j=0; j<this.consensus.length; j++)
			{
				
				if (_mats[i].id == this.consensus[j].id)
				{
					console.log(_mats[i].id, " = ",  this.consensus[j].id)
					this.consensus.remove(consensus[j]);
					_mats[i].setConsensus(false);
					console.log('REMOVED ITEM ID:', _mats[i].id);
				}
			}
		}
		//TV timeline.updateLayout(0,false);
		console.log('Size of consensus array', consensus.length);
		
		this.consensusPile.removeMatrices(_mats);
		this.consensusPile.draw();
		redrawPiles(piles)
	//	updateConsensusPile();
		//render()
    }
	
	/*
	//TV when an item is added/deleted from consensus pile then redraw consensus pile
	function updateConsensusPile()
	{
		// TODO: first pile() all matrices in consensus and then 
	//TV	var consensusPile = new Pile(0, scene, allPileOrdering[orderMenu.selectedIndex], _zoomFac);	
		//for (var i=0; i<this.consensus.length; i++)
		//{
	//TV		consensusPile.addMatrices(this.consensus);//([consensus[i]]);
		//}
        consensusPile.draw();		
		
            redrawPiles(piles)
            updateLayout(0, true)
            timeline.updateLayout();    
            render()
	}
	*/

    </script>
   
</body>
</html>